"use strict";(self.webpackChunkmy_learning_curve=self.webpackChunkmy_learning_curve||[]).push([[7950],{317:n=>{n.exports=JSON.parse('{"blogPosts":[{"id":"/05-higher-order-functions","metadata":{"permalink":"/my-learning-curve/blog/05-higher-order-functions","editUrl":"https://github.com/edouardmisset/my-learning-curve/tree/main/blog/05-higher-order-functions.md","source":"@site/blog/05-higher-order-functions.md","title":"Higher Order Functions","description":"Introduction","date":"2024-01-03T15:00:36.000Z","formattedDate":"January 3, 2024","tags":[],"readingTime":3.35,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"nextItem":{"title":"Typescript types","permalink":"/my-learning-curve/blog/01-types"}},"content":"## Introduction\\n\\nIn Javascript, functions are values (first-class citizens). This means that they can be assigned to a variable and/or passed as a value.\\n\\n```javascript\\nconst random = function () {\\n  return Math.random()\\n}\\n\\nconst giveMeRandom = random // assigns random to a variable\\n```\\n\\nThis single piece of knowledge allows us to write functional programming in this language. In functional programming, we heavily use higher-order functions.\\n\\n## The concept\\n\\n**Higher Order Functions** is simply a function that takes another function as an argument or returns a function.\\nThis is possible because functions are **first class citizens** in JavaScript, which means that they can be passed as arguments, returned from other functions, and stored in variables as objects.\\n\\nNB: Taking an other function as an argument is often referred as a **callback** function, because it is called back by the higher-order function.\\n\\nNB 2: Returning a function is often referred as a **currying** function, because it returns a function that takes the remaining arguments.\\n\\n### Currying and HOF\\n\\nMore on that on a later episode.\\nBasically, it allows us to write functions that take multiple arguments, and return a function that takes the remaining arguments.\\nThis is often done in order to make a \'specific\' function from a \'parent\' function.\\n\\n```javascript\\nfunction curry(f) {\\n  // curry(f) does the currying transform\\n  return function (a) {\\n    return function (b) {\\n      return f(a, b)\\n    }\\n  }\\n}\\n\\n// usage\\nfunction sum(a, b) {\\n  return a + b\\n}\\n\\nconst curriedSum = curry(sum)\\n\\nconsole.log(curriedSum(1)(2)) // 3\\n```\\n\\nNB: \u26a0\ufe0f Function expression are **NOT** hoisted.\\n\\n## The power of composition\\n\\nOne of the great advantages of using higher order functions is composition.\\n\\nWe can create smaller functions that only take care of one piece of logic. Then, we compose more complex functions by using different smaller functions.\\n\\nThis technique reduces bugs and makes our code easier to read, understand and maintain.\\n\\nBelow is an example of composition.\\n\\nGiven a sample array of numbers, we want to get:\\n\\n- The average grade of this classroom\\n- The average grade for the boys\\n- The average grade for the girls\\n- The highest & lowest grade for the boys\\n- The highest & lowest grade for the girls\\n\\n```javascript\\n// The data set\\nconst grades = [\\n  { name: \'John\', grade: 8, sex: \'M\' },\\n  { name: \'Sarah\', grade: 12, sex: \'F\' },\\n  { name: \'Bob\', grade: 16, sex: \'M\' },\\n  { name: \'Johnny\', grade: 2, sex: \'M\' },\\n  { name: \'Ethan\', grade: 4, sex: \'M\' },\\n  { name: \'Paula\', grade: 18, sex: \'F\' },\\n  { name: \'Donald\', grade: 5, sex: \'M\' },\\n  { name: \'Jennifer\', grade: 13, sex: \'F\' },\\n  { name: \'Courtney\', grade: 15, sex: \'F\' },\\n  { name: \'Jane\', grade: 9, sex: \'F\' },\\n]\\n\\n// The pure (simple) functions\\nconst isBoy = student => student.sex === \'M\'\\n\\nconst isGirl = student => student.sex === \'F\'\\n\\nconst getBoys = grades => grades.filter(isBoy)\\n\\nconst getGirls = grades => grades.filter(isGirl)\\n\\nconst average = grades =>\\n  grades.reduce((acc, current) => acc + current.grade, 0) / grades.length\\n\\nconst maxGrade = grades => Math.max(...grades.map(student => student.grade))\\n\\nconst minGrade = grades => Math.min(...grades.map(student => student.grade))\\n\\nconst classroomAverage = average(grades) // 10.2\\nconst boysAverage = average(getBoys(grades)) // 7\\nconst girlsAverage = average(getGirls(grades)) // 13.4\\nconst highestGrade = maxGrade(grades) // 18\\nconst lowestGrade = minGrade(grades) // 2\\nconst highestBoysGrade = maxGrade(getBoys(grades)) // 16\\nconst lowestBoysGrade = minGrade(getBoys(grades)) // 2\\nconst highestGirlsGrade = maxGrade(getGirls(grades)) // 18\\nconst lowestGirlsGrade = minGrade(getGirls(grades)) // 9\\n```\\n\\nThe outer functions, average for example, always take as an input the output from the inner functions. Therefore, the only condition to composition is to make sure that the output and input match (\u26a0\ufe0f type checking).\\n\\nAnd because each function is responsible for only one thing, it makes this code easier to debug and to test.\\n\\n## HOFs in practice\\n\\n(TBC)\\n\\n## Sources\\n\\n- Eloquent Javascript on [higher order](https://eloquentjavascript.net/05_higher_order.html)\\n- Dam Cosset from dev.to on [higher order functions in javascript](https://dev.to/damcosset/higher-order-functions-in-javascript-4j8b)\\n- Alex Devero on [HOF in JS](https://blog.alexdevero.com/higher-order-functions-javascript/)\\n- Javascript.info on [Currying](https://javascript.info/currying-partials)"},{"id":"/01-types","metadata":{"permalink":"/my-learning-curve/blog/01-types","editUrl":"https://github.com/edouardmisset/my-learning-curve/tree/main/blog/01-types.md","source":"@site/blog/01-types.md","title":"Typescript types","description":"Primitive types","date":"2023-10-06T15:52:45.000Z","formattedDate":"October 6, 2023","tags":[],"readingTime":1.64,"hasTruncateMarker":false,"authors":[{"name":"Edouard Misset","title":"Full Stack Engineer","url":"https://github.com/edouardmisset","imageURL":"https://github.com/edouardmisset.png","key":"Edouard"}],"frontMatter":{"authors":["Edouard"]},"unlisted":false,"prevItem":{"title":"Higher Order Functions","permalink":"/my-learning-curve/blog/05-higher-order-functions"},"nextItem":{"title":"Generics","permalink":"/my-learning-curve/blog/02-generics"}},"content":"## Primitive types\\n\\n```typescript\\n// boolean\\nlet isCool: boolean = false\\n\\n// number\\nlet age: number = 56\\n\\n// string\\nlet eyeColor: string = \'brown\'\\nlet favoriteQuote: string = `I\'m not old, I\'m only ${age}`\\n\\n// null and undefined\\nlet meh: undefined = undefined\\nlet noo: null = null\\n```\\n\\n## Complex types\\n\\n```typescript\\n// Array\\nlet pets: string[] = [\'cat\', \'mouse\', \'dragon\']\\nlet pets2: Array<string> = [\'pig\', \'lion\', \'dragon\']\\n\\n// Tuple\\nlet basket: [string, number]\\nbasket = [\'basketball\', 10]\\n\\n// Enum\\nenum Size {\\n  Small = 1,\\n  Medium = 2,\\n  Large = 3,\\n}\\nlet sizeName: string = Size[2]\\nalert(sizeName) // Displays \'Medium\' as its value is 2 above\\n\\ntype animals = \'cat\' | \'mouse\' | \'dragon\'\\n\\n// Any\\nlet whatever: any = \'aaaaghhhhhh noooooo!\'\\n\\n// void\\nlet sing = (): void => console.log(\'Lalalala\')\\n\\n// never\\nlet error = (): never => {\\n  throw Error(\'blah!\')\\n}\\n\\n// Type Assertion\\nlet ohHiThere: any = \'OH HI THERE\'\\nlet stringLength: number = (ohHiThere as string).length\\n\\ninterface CatArmy {\\n  count: number\\n  type: string\\n}\\n\\nlet dog = {} as CatArmy\\ndog.count = 5\\n\\n// Interface\\ninterface RobotArmy {\\n  count: number\\n  type: string\\n  magic?: string\\n}\\n\\nlet fightRobotArmy = (robots: RobotArmy): void => {\\n  console.log(\'FIGHT!\')\\n}\\nlet fightRobotArmy2 = (robots: {\\n  count: number\\n  type: string\\n  magic?: string\\n}): void => {\\n  console.log(\'FIGHT!\')\\n}\\n\\n// Function\\nlet fightRobotArmyF = (robots: RobotArmy): void => {\\n  console.log(\'FIGHT!\')\\n}\\nlet fightRobotArmy2F = (robots: {\\n  count: number\\n  type: string\\n  magic?: string\\n}): void => {\\n  console.log(\'FIGHT!\')\\n}\\n\\n// *** Class\\nclass Animal {\\n  constructor(private sound: string) {}\\n  greet(): string {\\n    return \'Hello, \' + this.sing\\n  }\\n}\\n\\nlet lion = new Animal(\'Lion\')\\nlion.greet() // Displays \'Hello, Lion\'\\n\\n//In TypeScript, there are several places where type inference\\n//is used to provide type information when there is no explicit\\n//type annotation. For example, in this code\\nlet x = 3\\n// automatically detects x is a number.\\n\\n// Union Type\\nlet confused: string | number = \'hello\'\\n```"},{"id":"/02-generics","metadata":{"permalink":"/my-learning-curve/blog/02-generics","editUrl":"https://github.com/edouardmisset/my-learning-curve/tree/main/blog/02-generics.md","source":"@site/blog/02-generics.md","title":"Generics","description":"Example with a class","date":"2021-10-20T14:22:27.000Z","formattedDate":"October 20, 2021","tags":[{"label":"generics","permalink":"/my-learning-curve/blog/tags/generics"},{"label":"typescript","permalink":"/my-learning-curve/blog/tags/typescript"},{"label":"programming","permalink":"/my-learning-curve/blog/tags/programming"}],"readingTime":0.215,"hasTruncateMarker":false,"authors":[{"name":"Edouard Misset","title":"Full Stack Engineer","url":"https://github.com/edouardmisset","imageURL":"https://github.com/edouardmisset.png","key":"Edouard"}],"frontMatter":{"authors":["Edouard"],"tags":["generics","typescript","programming"]},"unlisted":false,"prevItem":{"title":"Typescript types","permalink":"/my-learning-curve/blog/01-types"},"nextItem":{"title":"Memoization","permalink":"/my-learning-curve/blog/04-memoization"}},"content":"## Example with a class\\n\\n```typescript\\nclass HoldAnything<T> {\\n  // T is the name usually given to the generic \'type of data\'\\n  data: T\\n}\\n\\nconst holdNumber = new HoldAnything<number>()\\nholdNumber.data = 123\\nconst holdString = new HoldAnything<string>()\\nholdString.data = \'Hello Wall-e\'\\n```"},{"id":"/04-memoization","metadata":{"permalink":"/my-learning-curve/blog/04-memoization","editUrl":"https://github.com/edouardmisset/my-learning-curve/tree/main/blog/04-memoization.md","source":"@site/blog/04-memoization.md","title":"Memoization","description":"Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.","date":"2021-10-12T10:55:31.000Z","formattedDate":"October 12, 2021","tags":[{"label":"JavaScript","permalink":"/my-learning-curve/blog/tags/java-script"},{"label":"Optimization","permalink":"/my-learning-curve/blog/tags/optimization"},{"label":"Memoization","permalink":"/my-learning-curve/blog/tags/memoization"},{"label":"Closures","permalink":"/my-learning-curve/blog/tags/closures"},{"label":"Higher Order Functions","permalink":"/my-learning-curve/blog/tags/higher-order-functions"}],"readingTime":1.335,"hasTruncateMarker":false,"authors":[{"name":"Edouard Misset","title":"Full Stack Engineer","url":"https://github.com/edouardmisset","imageURL":"https://github.com/edouardmisset.png","key":"Edouard"}],"frontMatter":{"authors":["Edouard"],"tags":["JavaScript","Optimization","Memoization","Closures","Higher Order Functions"]},"unlisted":false,"prevItem":{"title":"Generics","permalink":"/my-learning-curve/blog/02-generics"},"nextItem":{"title":"Destructuring Assignment","permalink":"/my-learning-curve/blog/03-desctructuring"}},"content":"> Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.\\n>\\n> ~ Wikipedia\\n\\n## The concept\\n\\n> As our applications grow and begin to carry out heavier computations, there comes an increasing need for speed (\ud83c\udfce\ufe0f) and the optimization of processes becomes a necessity. When we ignore this concern, we end up with programs that take a lot of time and consume a monstrous chunk of system resources during execution.\\n>\\n> Memoization is an optimization technique that speeds up applications by storing the results of expensive function calls and returning the cached result when the same inputs occur again.\\n>\\n> ~ Philip Obosi\\n\\nMemoization is built upon two key JS concepts:\\n\\n- **Closures** (function and the lexical environment where it was declared)\\n- **Higher Order Functions** (returning / accepting functions from functions)\\n\\n## Examples\\n\\n### Basic example\\n\\nSimple memoization exemple:\\n\\n```javascript\\nconst cache = {}\\nfunction memoizedAddTo1000(number) {\\n  if (number in cache) {\\n    return cache[number]\\n  } else {\\n    console.log(\'(Long time) calculation...\')\\n    cache[number] = number + 1000\\n    return cache[number]\\n  }\\n}\\n\\nconsole.log(\'First call: \', memoizedAddTo1000(1))\\nconsole.log(\'Second call: \', memoizedAddTo1000(1))\\n\\n// (Long time) calculation...\\n// First call: 1001\\n// Second call: 1001\\n```\\n\\n### Advanced example\\n\\nMemoization of a function:\\n\\n```javascript\\nconst cache = {}\\nfunction memoize(fn) {\\n  return function (...args) {\\n    if (cache[args]) {\\n      return cache[args]\\n    }\\n    const result = fn.apply(this, args)\\n    cache[args] = result\\n    return result\\n  }\\n}\\n```\\n\\n## Resources\\n\\nUnderstanding Memoization in JavaScript by [better.dev](https://www.better.dev/understanding-memoization-in-javascript)\\n\\nMemoization [Wikipedia](https://en.wikipedia.org/wiki/Memoization)\\n\\nAndrei Neagoie [ZTM](https://zerotomastery.io/)"},{"id":"/03-desctructuring","metadata":{"permalink":"/my-learning-curve/blog/03-desctructuring","editUrl":"https://github.com/edouardmisset/my-learning-curve/tree/main/blog/03-desctructuring.md","source":"@site/blog/03-desctructuring.md","title":"Destructuring Assignment","description":"The concept","date":"2021-04-28T08:43:09.000Z","formattedDate":"April 28, 2021","tags":[{"label":"JavaScript","permalink":"/my-learning-curve/blog/tags/java-script"},{"label":"ES6","permalink":"/my-learning-curve/blog/tags/es-6"},{"label":"Destructuring","permalink":"/my-learning-curve/blog/tags/destructuring"},{"label":"Nested Property","permalink":"/my-learning-curve/blog/tags/nested-property"},{"label":"Function Arguments","permalink":"/my-learning-curve/blog/tags/function-arguments"},{"label":"Variables Swapping","permalink":"/my-learning-curve/blog/tags/variables-swapping"}],"readingTime":2.565,"hasTruncateMarker":false,"authors":[{"name":"Edouard Misset","title":"Full Stack Engineer","url":"https://github.com/edouardmisset","imageURL":"https://github.com/edouardmisset.png","key":"Edouard"}],"frontMatter":{"authors":["Edouard"],"tags":["JavaScript","ES6","Destructuring","Nested Property","Function Arguments","Variables Swapping"]},"unlisted":false,"prevItem":{"title":"Memoization","permalink":"/my-learning-curve/blog/04-memoization"}},"content":"## The concept\\n\\nThe **destructuring assignment** syntax is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables.\\nAvailable from ES6 (2015) onward.\\n\\nOR\\n\\n> Take values from arrays or properties from objects and set them as local variables.\\n>\\n> ~ Fireship.io\\n\\n## Examples\\n\\n### With arrays\\n\\n#### The bascis\\n\\n```javascript\\n// The basics\\nconst food = [\'\ud83e\udd53\', \'\ud83c\udf55\', \'\ud83c\udf5f\', \'\ud83c\udf54\', \'\ud83c\udf2e\']\\nconst [bacon, , , , taco] = food\\n\\nconsole.log(bacon, taco) // \ud83e\udd53 \ud83c\udf2e\\n```\\n\\n#### Using the spread operator\\n\\n```javascript\\n// Using the spread operator\\nconst food = [\'\ud83e\udd53\', \'\ud83c\udf55\', \'\ud83c\udf5f\', \'\ud83e\udd6c\', \'\ud83e\udd66\']\\nconst [, , , ...noJunkFood] = food\\n\\nconsole.log(noJunkFood) // [ \'\ud83e\udd6c\', \'\ud83e\udd66\' ]\\n```\\n\\n#### Using a default value\\n\\n```javascript\\n// Using a default value\\nconst food = [undefined, \'\ud83c\udf55\', \'\ud83c\udf5f\']\\nconst [bacon = \'\ud83d\udc16\', pizza, fries] = food\\n\\nconsole.log(bacon) // \ud83d\udc16\\n```\\n\\n### With objects\\n\\n#### The basics\\n\\n```javascript\\n// The basics\\nconst animals = {\\n  snake: \'\ud83d\udc0d\',\\n  monkey: \'\ud83d\udc35\',\\n  octopus: \'\ud83d\udc19\',\\n}\\nconst { octopus } = animals\\n\\nconsole.log(octopus) // \ud83d\udc19\\n```\\n\\n#### Using the spread operator\\n\\n```javascript\\n// Using the spread operator\\nconst animals = {\\n  snake: \'\ud83d\udc0d\',\\n  monkey: \'\ud83d\udc35\',\\n  octopus: \'\ud83d\udc19\',\\n}\\nconst { ...rest } = animals\\n\\nconsole.log(rest) // { snake: \'\ud83d\udc0d\', monkey: \'\ud83d\udc35\', octopus: \'\ud83d\udc19\' }\\n\\n// Overriding a value using the spread operator\\nconst animals = {\\n  snake: \'\ud83d\udc0d\',\\n  monkey: \'\ud83d\udc35\',\\n  octopus: \'\ud83d\udc19\',\\n}\\nconst newAnimals = { ...animals, snake: \'\ud83e\udd8e\' }\\n\\nconsole.log(newAnimals) // { snake: \'\ud83e\udd8e\', monkey: \'\ud83d\udc35\', octopus: \'\ud83d\udc19\' }\\n```\\n\\n#### Using a default value\\n\\n```javascript\\n// Using a default value\\nconst animals = {\\n  snake: \'\ud83d\udc0d\',\\n  monkey: \'\ud83d\udc35\',\\n  octopus: undefined,\\n}\\nconst { octopus = \'\ud83e\udd91\' } = animals\\n\\nconsole.log(octopus) // \ud83e\udd91\\n```\\n\\n#### Renaming property\\n\\n```javascript\\n// Renaming property\\nconst animals = {\\n  snake: \'\ud83d\udc0d\',\\n  monkey: \'\ud83d\udc35\',\\n  octopus: \'\ud83e\udd91\',\\n}\\nconst { octopus: squid } = animals\\n\\nconsole.log(squid) // \ud83e\udd91\\n```\\n\\n#### Nested property\\n\\n```javascript\\n// Nested property\\nconst family = {\\n  parent: {\\n    child: \'\ud83d\udc76\',\\n  },\\n}\\nconst {\\n  parent: { child },\\n} = family\\n\\nconsole.log(child) // \ud83d\udc76\\n```\\n\\n#### Desctructuring within function arguments\\n\\n```javascript\\n// Desctructuring within function arguments\\nconst user = {\\n  id: 0,\\n  name: \'John\',\\n}\\n\\nfunction sayHi({ id, name }) {\\n  console.log(`Hi ${name}!`)\\n}\\n\\nsayHi(user) // Hi John!\\n```\\n\\n## Bonus\\n\\n#### Variables swapping\\n\\n```javascript\\n// Variables swapping\\nlet a = \'foo\'\\nlet b = \'bar\'\\n\\n;[a, b] = [b, a]\\n\\nconsole.log(\'a:\', a, \'b:\', b) // a: bar b: foo\\n```\\n\\n#### Computed property name\\n\\n```javascript\\n// Computed property name\\nconst rando = randomKey()\\n\\nconst obj = {\\n  [rando]: 42,\\n}\\n\\nconst { [rando]: myKey } = obj\\n```\\n\\n#### Conditionally added property / value\\n\\n```javascript\\nconst trueCondition = true\\nconst falseCondition = false\\n\\nconst obj = {\\n  ...(trueCondition && { \'\ud83d\udc15\': \'woof\' }),\\n  ...(falseCondition && { \'\ud83d\udc08\': \'meow\' }),\\n}\\n\\nconsole.log(obj)\\n// { \'\ud83d\udc15\': \'woof\' }\\n\\nconst arr = [\\n  ...(trueCondition ? [\'\ud83d\udc15\'] : []),\\n  ...(falseCondition ? [\'\ud83d\udc08\'] : []),\\n]\\n\\nconsole.log(arr)\\n// [ \'\ud83d\udc15\' ]\\n```\\n\\n## Resources\\n\\nIntroduction by [Fireship.io](https://www.youtube.com/watch?v=UgEaJBz3bjY)\\n\\nOfficial documentation on [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)\\n\\nAdoption on [CanIUse](https://caniuse.com/mdn-javascript_operators_destructuring)"}]}')}}]);