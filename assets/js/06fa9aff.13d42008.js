"use strict";(self.webpackChunkmy_learning_curve=self.webpackChunkmy_learning_curve||[]).push([[500],{8191:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>y,toc:()=>h});var r=n(4848),i=n(8453),s=n(1432);const p='// biome-ignore lint/suspicious/noExplicitAny: ...because it\'s a type helper file\nexport type ObjectType<T = any> = Record<string, T>\n\nexport type Value = string | number | boolean | null | undefined\nexport type DefinedValue = string | number | boolean\n\n/**\n * Constructs a type by overriding some properties of an original type with properties from another type.\n *\n * This type helper uses the `Omit` and `keyof` utility types from TypeScript.\n * It first omits the keys of the `OverrideType` from the `OriginalType`, and then combines the result with the `OverrideType`.\n * This means that properties in the `OverrideType` will override properties in the `OriginalType`.\n *\n * @template OriginalType The original type.\n * @template OverrideType The type that should override properties in the original type.\n *\n * @example\n * type Person = {\n *   name: string;\n *   age: number;\n * };\n *\n * type Employee = {\n *   age: string;\n *   company: string;\n * };\n *\n * type EmployeePerson = Override<Person, Employee>;\n * // Equivalent to: { name: string; age: string; company: string; }\n */\nexport type Override<OriginalType, OverrideType> = Omit<\n  OriginalType,\n  keyof OverrideType\n> &\n  OverrideType\n\n/**\n * Constructs a type by making some properties of an existing type required.\n *\n * This type helper uses the `Omit`, `Pick`, and `Required` utility types from TypeScript.\n * It first omits the specified keys from the original type, and then makes those keys required.\n *\n * @template Obj The original type.\n * @template Key The keys of the properties that should be made required. It extends `keyof T`, which means it can be any key of `T`. The default value is `keyof T`, which means all keys of `T`.\n *\n * @example\n * type Person = {\n *   name: string;\n *   age?: number;\n * };\n *\n * type PersonWithRequiredAge = RequireKey<Person, \'age\'>;\n * // Equivalent to: { name: string; age: number; }\n */\nexport type RequireKey<\n  Obj extends ObjectType<unknown>,\n  Key extends keyof Obj = keyof Obj,\n> = Omit<Obj, Key> & Required<Pick<Obj, Key>>\n\n/**\n * Constructs a type by making some properties of an existing type optional.\n *\n * This type helper uses the `Omit` and `Partial` utility types from TypeScript.\n * It first omits the specified keys from the original type, and then makes those keys optional.\n *\n * @template Obj The original type.\n * @template Key The keys of the properties that should be made optional. It extends `keyof T`, which means it can be any key of `T`. The default value is `keyof T`, which means all keys of `T`.\n *\n * @example\n * type Person = {\n *   name: string;\n *   age: number;\n * };\n *\n * type PersonWithOptionalAge = PartialProperty<Person, \'age\'>;\n * // Equivalent to: { name: string; age?: number; }\n */\nexport type PartialProperty<\n  Obj extends ObjectType<unknown>,\n  Key extends keyof Obj = keyof Obj,\n> = Omit<Obj, Key> & Partial<Pick<Obj, Key>>\n\n/**\n * Constructs a type by excluding `null` from the possible values of some properties of an existing type.\n *\n * This type helper uses the `Exclude` utility type from TypeScript.\n * It iterates over the keys of the original type, and for each key, it creates a new type that excludes `null` from the possible values of that property.\n *\n * @template Obj The original type. It extends `object`, which means it can be any object type.\n * @template Key The keys of the properties that should exclude `null`. It extends `keyof T`, which means it can be any key of `T`. The default value is `keyof T`, which means all keys of `T`.\n *\n * @example\n * type Person = {\n *   name: string | null;\n *   age: number | null;\n * };\n *\n * type PersonWithoutNull = NotNullProperty<Person>;\n * // Equivalent to: { name: string; age: number; }\n */\nexport type NotNullProperty<\n  Obj extends ObjectType<unknown>,\n  Key extends keyof Obj = keyof Obj,\n> = {\n  [P in Key]: Exclude<Obj[Key], null>\n}\n\n/**\n * A TypeScript type alias called `Prettify`.\n * It takes a type as its argument and returns a new type that has the same properties as the original type,\n * but the properties are not intersected. This means that the new type is easier to read and understand.\n */\nexport type Prettify<Obj> = {\n  [Key in keyof Obj]: Obj[Key]\n  // eslint-disable-next-line @typescript-eslint/ban-types\n} & {}\n\n/**\n * Constructs a type consisting of the values of the properties of an existing type.\n *\n * This type helper uses the `keyof` and indexed access (`[]`) types from TypeScript.\n * It creates a new type that includes the types of all values of the properties of the original type.\n *\n * @template Obj The original type.\n *\n * @example\n * type Person = {\n *   name: string;\n *   age: number;\n * };\n *\n * type PersonValues = ObjectValues<Person>;\n * // Equivalent to: string | number\n */\nexport type ObjectValues<Obj> = Obj[keyof Obj]\n\n/**\n * Represents a type that can be either a specific string (or union of strings) `T` or any string.\n *\n * @template S - A string literal type.\n * @typedef {S | Omit<string, S>} LooseAutoComplete\n *\n * @example\n * // Define a type that can be either "red" or any string excluding "red"\n * type RedOrOther = LooseAutoComplete<"red">;\n *\n * // This is valid because "red" is one of the allowed values\n * let example3: RedOrOther = "red";\n *\n * // This is also valid because any string excluding "red" is allowed\n * let example4: RedOrOther = "blue";\n */\nexport type LooseAutoComplete<S extends string> = S | Omit<string, S>\n\n/**\n * Constructs a type consisting of the values of the properties of an existing type.\n *\n * This type helper is similar to `ObjectValues`, but it works with generic types.\n * It extracts the values of the properties of the generic type `T`.\n * If `T` is a record type, it returns the union of the values of the properties of `T`.\n * If `T` is not a record type, it returns `never`.\n *\n * @template T The generic type.\n * @example\n * ```ts\n * const person = {\n *  name: Adam;\n *  age: 21;\n * };\n * type PersonValues = GetObjectValues<person>;\n * // Equivalent to: \'Adam\' | 21\n */\nexport type GetObjectValues<T> = T extends Record<string, infer V> ? V : never\n',o={},a="Type Helpers",y={id:"snippets/Typescript/Type/type-helpers",title:"Type Helpers",description:"",source:"@site/docs/snippets/Typescript/Type/type-helpers.mdx",sourceDirName:"snippets/Typescript/Type",slug:"/snippets/Typescript/Type/type-helpers",permalink:"/my-learning-curve/docs/snippets/Typescript/Type/type-helpers",draft:!1,unlisted:!1,editUrl:"https://github.com/edouardmisset/my-learning-curve/tree/main/docs/snippets/Typescript/Type/type-helpers.mdx",tags:[],version:"current",frontMatter:{},sidebar:"snippetsSidebar",previous:{title:"Find node in tree",permalink:"/my-learning-curve/docs/snippets/Typescript/Tree/find-node-in-tree"},next:{title:"Helpers",permalink:"/my-learning-curve/docs/snippets/Typescript/helpers"}},l={},h=[];function u(e){const t={h1:"h1",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"type-helpers",children:"Type Helpers"}),"\n",(0,r.jsx)(s.A,{language:"ts",children:p})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);