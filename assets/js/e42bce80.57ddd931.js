"use strict";(self.webpackChunkmy_learning_curve=self.webpackChunkmy_learning_curve||[]).push([[7737],{7075:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>c,default:()=>m,frontMatter:()=>o,metadata:()=>y,toc:()=>u});var r=t(5893),a=t(1151),s=t(9286);const i="/**\n * Returns the elements that are common to both arrays.\n *\n * This function finds the elements that are in both arrays.\n * It uses the `filter` method to check that each element of the first array is also in the second array.\n *\n * @template T The type of the elements in the arrays. It can be any type.\n *\n * @param {T[]} leftArray The first array.\n * @param {T[]} rightArray The second array.\n *\n * @returns {T[]} An array that contains all elements that are in both arrays.\n *\n * @example\n * const array1 = [1, 2, 3];\n * const array2 = [2, 3, 4];\n * const result = commonElements(array1, array2); // [2, 3]\n */\nexport const commonElements = <T>(leftArray: T[], rightArray: T[]): T[] =>\n  leftArray.filter(item => new Set(rightArray).has(item))\n\n/**\n * @description Alias for the {@link commonElements} function.\n */\nexport const intersection = commonElements\n\n/**\n * Returns the unique elements from the combination of two arrays.\n *\n * This function combines two arrays and only keeps the unique elements.\n * It uses the `Set` object to remove duplicates.\n *\n * @template T The type of the elements in the arrays. It can be any type.\n *\n * @param {T[]} leftArray The first array.\n * @param {T[]} rightArray The second array.\n *\n * @returns {T[]} An array that contains all unique elements from both arrays.\n *\n * @example\n * const array1 = [1, 2, 3];\n * const array2 = [2, 3, 4];\n * const result = mergeUnique(array1, array2); // [1, 2, 3, 4]\n */\nexport const mergeUnique = <T>(leftArray: T[], rightArray: T[]): T[] =>\n  Array.from(new Set([...leftArray, ...rightArray]))\n\n/**\n * @description Alias for the {@link mergeUnique} function.\n */\nexport const union = mergeUnique\n\n/**\n * Returns the elements that are unique to the first array.\n *\n * This function finds the elements that are in the first array but not in any of the others.\n * It uses the `some` method to check that each element of the first array is not in any of the other arrays.\n *\n * @template T The type of the elements in the arrays. It can be any type.\n *\n * @param {T[]} firstArray The first array.\n * @param {...T[][]} otherArrays The other arrays.\n *\n * @returns {T[]} An array that contains all elements that are in the first array but not in any of the other arrays.\n *\n * @example\n * const array1 = [1, 2, 3];\n * const array2 = [2, 3, 4];\n * const array3 = [3, 4, 5];\n * const result = uniqueInFirst(array1, array2, array3); // [1]\n */\nexport const uniqueInFirst = <T>(firstArray: T[], ...otherArrays: T[][]): T[] =>\n  firstArray.filter(\n    item => !otherArrays.some(array => new Set(array).has(item)),\n  )\n\n/**\n * @description Alias for the {@link uniqueInFirst} function.\n */\nexport const setDifference = uniqueInFirst\n\n/**\n * Returns the unique elements from n arrays.\n *\n * This function uses the `setDifference` function to find the elements that are in one array but not in the others.\n * It uses the `reduce` method to apply this process to each array in turn, starting with the first two arrays and then using their symmetric difference as the starting point for the next call.\n *\n * @template T The type of the elements in the arrays. It can be any type.\n *\n * @param {...T[][]} arrays The arrays to find the unique elements of.\n *\n * @returns {T[]} An array that contains all elements that are in exactly one of the input arrays.\n *\n * @example\n * const array1 = [1, 2, 3];\n * const array2 = [2, 3, 4];\n * const array3 = [3, 4, 5];\n * const result = uniqueElements(array1, array2, array3); // [1, 5]\n */\nexport const uniqueElements = <T>(...arrays: T[][]): T[] =>\n  arrays.reduce((previousArray, currentArray) => [\n    ...uniqueInFirst(previousArray, currentArray),\n    ...uniqueInFirst(currentArray, previousArray),\n  ])\n\n/**\n * @description Alias for the {@link uniqueElements} function.\n */\nexport const symmetricDifference = uniqueElements\n",o={},c="Sets",y={id:"snippets/Typescript/Set/sets",title:"Sets",description:"",source:"@site/docs/snippets/Typescript/Set/sets.mdx",sourceDirName:"snippets/Typescript/Set",slug:"/snippets/Typescript/Set/sets",permalink:"/my-learning-curve/docs/snippets/Typescript/Set/sets",draft:!1,unlisted:!1,editUrl:"https://github.com/edouardmisset/my-learning-curve/tree/main/docs/snippets/Typescript/Set/sets.mdx",tags:[],version:"current",frontMatter:{},sidebar:"snippetsSidebar",previous:{title:"Sort an Object Keys",permalink:"/my-learning-curve/docs/snippets/Typescript/Object/sort-keys"},next:{title:"Change the capitalization of strings",permalink:"/my-learning-curve/docs/snippets/Typescript/String/casing"}},h={},u=[];function l(e){const n={h1:"h1",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"sets",children:"Sets"}),"\n",(0,r.jsx)(s.Z,{language:"ts",children:i})]})}function m(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);