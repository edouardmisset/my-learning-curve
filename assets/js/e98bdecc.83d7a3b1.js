"use strict";(self.webpackChunkmy_learning_curve=self.webpackChunkmy_learning_curve||[]).push([[1383],{1104:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>m,frontMatter:()=>i,metadata:()=>h,toc:()=>y});var r=t(5893),a=t(1151),s=t(9286);const o="/**\n * Returns the elements that are common to both arrays.\n *\n * This function finds the elements that are in both arrays.\n * It uses the `filter` method to check that each element of the first array is also in the second array.\n *\n * @template T The type of the elements in the arrays. It can be any type.\n *\n * @param {T[]} leftArray The first array.\n * @param {T[]} rightArray The second array.\n *\n * @returns {T[]} An array that contains all elements that are in both arrays.\n *\n * @example\n * const array1 = [1, 2, 3];\n * const array2 = [2, 3, 4];\n * const result = commonElements(array1, array2); // [2, 3]\n */\nexport const commonElements = <T>(leftArray: T[], rightArray: T[]): T[] =>\n  leftArray.filter(item => new Set(rightArray).has(item))\nexport const intersection = commonElements\n\n/**\n * Returns the unique elements from the combination of two arrays.\n *\n * This function combines two arrays and only keeps the unique elements.\n * It uses the `Set` object to remove duplicates.\n *\n * @template T The type of the elements in the arrays. It can be any type.\n *\n * @param {T[]} leftArray The first array.\n * @param {T[]} rightArray The second array.\n *\n * @returns {T[]} An array that contains all unique elements from both arrays.\n *\n * @example\n * const array1 = [1, 2, 3];\n * const array2 = [2, 3, 4];\n * const result = mergeUnique(array1, array2); // [1, 2, 3, 4]\n */\nexport const mergeUnique = <T>(leftArray: T[], rightArray: T[]): T[] =>\n  Array.from(new Set([...leftArray, ...rightArray]))\nexport const union = mergeUnique\n\n/**\n * Returns the elements that are unique to the first array.\n *\n * This function finds the elements that are in the first array but not in any of the others.\n * It uses the `some` method to check that each element of the first array is not in any of the other arrays.\n *\n * @template T The type of the elements in the arrays. It can be any type.\n *\n * @param {T[]} firstArray The first array.\n * @param {...T[][]} otherArrays The other arrays.\n *\n * @returns {T[]} An array that contains all elements that are in the first array but not in any of the other arrays.\n *\n * @example\n * const array1 = [1, 2, 3];\n * const array2 = [2, 3, 4];\n * const array3 = [3, 4, 5];\n * const result = uniqueInFirst(array1, array2, array3); // [1]\n */\nexport const uniqueInFirst = <T>(firstArray: T[], ...otherArrays: T[][]): T[] =>\n  firstArray.filter(item => !otherArrays.some(array => new Set(array).has(item)))\nexport const setDifference = uniqueInFirst\n\n/**\n * Returns the unique elements from n arrays.\n *\n * This function uses the `setDifference` function to find the elements that are in one array but not in the others.\n * It uses the `reduce` method to apply this process to each array in turn, starting with the first two arrays and then using their symmetric difference as the starting point for the next call.\n *\n * @template T The type of the elements in the arrays. It can be any type.\n *\n * @param {...T[][]} arrays The arrays to find the unique elements of.\n *\n * @returns {T[]} An array that contains all elements that are in exactly one of the input arrays.\n *\n * @example\n * const array1 = [1, 2, 3];\n * const array2 = [2, 3, 4];\n * const array3 = [3, 4, 5];\n * const result = uniqueElements(array1, array2, array3); // [1, 5]\n */\nexport const uniqueElements = <T>(...arrays: T[][]): T[] =>\n  arrays.reduce((previousArray, currentArray) => [\n    ...uniqueInFirst(previousArray, currentArray),\n    ...uniqueInFirst(currentArray, previousArray),\n  ])\nexport const symmetricDifference = uniqueElements\n\n// const left = [1, 2, 3]\n// const right = [2, 3, 4]\n\n// const one = [1, 2, 3, 4, 5, 6]\n// const two = [3, 4]\n// const three = [6]\n\n// console.log(intersection(left, right)) // [2, 3]\n// console.log(commonElements(left, right)) // [2, 3]\n\n// console.log(union(left, right)) // [1, 2, 3, 4]\n// console.log(mergeUnique(left, right)) // [1, 2, 3, 4]\n\n// console.log(uniqueInFirst(left, right)) // [1]\n// console.log(setDifference(left, right)) // [1]\n// console.log(uniqueInFirst(one, two, three)) // [1, 2, 5]\n// console.log(setDifference(one, two, three)) // [1, 2, 5]\n\n// console.log(uniqueElements(left, right))  // [1, 4]\n// console.log(symmetricDifference(left, right)) // [1, 4]\n",i={},c="Sets",h={id:"snippets/Typescript/sets",title:"Sets",description:"",source:"@site/docs/snippets/Typescript/sets.mdx",sourceDirName:"snippets/Typescript",slug:"/snippets/Typescript/sets",permalink:"/my-learning-curve/docs/snippets/Typescript/sets",draft:!1,unlisted:!1,editUrl:"https://github.com/edouardmisset/my-learning-curve/tree/main/docs/snippets/Typescript/sets.mdx",tags:[],version:"current",frontMatter:{},sidebar:"snippetsSidebar",previous:{title:"Helpers",permalink:"/my-learning-curve/docs/snippets/Typescript/helpers"},next:{title:"Shallow comparison",permalink:"/my-learning-curve/docs/snippets/Typescript/shallow-comparison"}},l={},y=[];function u(e){const n={h1:"h1",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"sets",children:"Sets"}),"\n",(0,r.jsx)(s.Z,{language:"ts",children:o})]})}function m(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);