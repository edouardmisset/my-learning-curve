---
date: 2025-11-19
title: Design Patterns in TypeScript
excerpt: "A practical guide to the most useful design patterns for full-stack TypeScript developers, with real-world examples."
tags: ['TypeScript', 'Design Patterns', 'Architecture', 'Best Practices']
lastUpdated: 2025-11-19
---

import Disclaimer from '~/components/Disclaimer.astro';

## Definition

> Design patterns are typical solutions to common problems in software design.
> Each pattern is like a blueprint that you can customize to solve a particular
> design problem in your code.
>
> ~ Refactoring Guru

{/* <!-- truncate --> */}

## The concept

As full-stack developers, we often encounter the same problems repeatedly: how to manage a single database connection, how to handle different payment methods, or how to integrate a third-party API that doesn't match our internal interfaces.

Design patterns provide a shared vocabulary and proven solutions. Instead of reinventing the wheel, we can apply these patterns to write code that is more flexible, reusable, and maintainable.

Here are some of the most relevant patterns for a TypeScript full-stack context.

## Creational Patterns

These patterns provide object creation mechanisms that increase flexibility and reuse of existing code.

### Singleton

**The Concept:** Ensure a class has only one instance and provide a global point of access to it.

**Real-world use case:** Database connections or Configuration managers. You don't want to open a new connection pool for every request.

```typescript
class Database {
  private static instance: Database;

  private constructor() {
    // Private constructor prevents direct instantiation
    console.log('Connecting to database...');
  }

  public static getInstance(): Database {
    if (!Database.instance) {
      Database.instance = new Database();
    }
    return Database.instance;
  }

  public query(sql: string): void {
    console.log(`Executing: ${sql}`);
  }
}

// Usage
const db1 = Database.getInstance();
const db2 = Database.getInstance();

console.log(db1 === db2); // true
```

#### Functional Alternative: Modules

In TypeScript/ES6, modules are singletons by default.

```typescript
// database.ts
export const db = new DatabaseConnection();
```

### Factory Method

**The Concept:** Provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.

**Real-world use case:** A notification system that can send emails, SMS, or Push notifications based on user preference.

```typescript
interface Notification {
  send(message: string): void;
}

class EmailNotification implements Notification {
  send(message: string) { console.log(`Sending Email: ${message}`); }
}

class SMSNotification implements Notification {
  send(message: string) { console.log(`Sending SMS: ${message}`); }
}

class NotificationFactory {
  static create(type: 'email' | 'sms'): Notification {
    if (type === 'email') return new EmailNotification();
    if (type === 'sms') return new SMSNotification();
    throw new Error('Unknown notification type');
  }
}

// Usage
const notifier = NotificationFactory.create('email');
notifier.send('Hello World');
```

#### Functional Alternative: Simple Factory Function

```typescript
const createNotifier = (type: 'email' | 'sms') => {
  if (type === 'email') return (msg: string) => console.log(`Email: ${msg}`);
  if (type === 'sms') return (msg: string) => console.log(`SMS: ${msg}`);
  throw new Error('Unknown type');
};
```

### Builder

**The Concept:** Lets you construct complex objects step by step. It allows you to produce different types and representations of an object using the same construction code.

**Real-world use case:** Creating complex test data or building SQL queries dynamically.

```typescript
class UserBuilder {
  private user: { name: string; email?: string; role: string };

  constructor(name: string) {
    this.user = { name, role: 'user' };
  }

  withEmail(email: string) {
    this.user.email = email;
    return this;
  }

  asAdmin() {
    this.user.role = 'admin';
    return this;
  }

  build() {
    return this.user;
  }
}

// Usage
const admin = new UserBuilder('Alice').withEmail('alice@example.com').asAdmin().build();
```

### Abstract Factory

**The Concept:** Lets you produce families of related objects without specifying their concrete classes.

**Real-world use case:** Cross-platform UI components (Windows vs Mac buttons) or Database drivers (PostgreSQL vs MySQL repositories).

```typescript
interface Button {
  render(): void;
}

class WindowsButton implements Button {
  render() { console.log('Rendering Windows Button'); }
}

class MacButton implements Button {
  render() { console.log('Rendering Mac Button'); }
}

interface GUIFactory {
  createButton(): Button;
}

class WindowsFactory implements GUIFactory {
  createButton() { return new WindowsButton(); }
}

class MacFactory implements GUIFactory {
  createButton() { return new MacButton(); }
}

// Usage
function createUI(factory: GUIFactory) {
  const button = factory.createButton();
  button.render();
}
```

### Prototype

**The Concept:** Lets you copy existing objects without making your code dependent on their classes.

**Real-world use case:** Cloning complex objects like game entities or configuration objects where creating a new instance from scratch is costly.

```typescript
class Shape {
  constructor(public x: number, public y: number, public color: string) {}

  clone(): Shape {
    return new Shape(this.x, this.y, this.color);
  }
}

const circle = new Shape(10, 10, 'red');
const anotherCircle = circle.clone();
```

## Structural Patterns

These patterns explain how to assemble objects and classes into larger structures while keeping these structures flexible and efficient.

### Adapter

**The Concept:** Allows objects with incompatible interfaces to collaborate.

**Real-world use case:** Integrating a legacy payment gateway or a 3rd party library that doesn't match your application's interface.

```typescript
// Your application expects this interface
interface Logger {
  log(message: string): void;
}

// 3rd party library has this interface
class ExternalAnalyticsService {
  sendEvent(eventName: string, data: object) {
    console.log(`External Analytics: ${eventName}`, data);
  }
}

// Adapter
class AnalyticsAdapter implements Logger {
  constructor(private service: ExternalAnalyticsService) {}

  log(message: string): void {
    this.service.sendEvent('log_entry', { message });
  }
}
```

### Decorator

**The Concept:** Lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.

**Real-world use case:** Adding logging, caching, or validation to API handlers (common in NestJS or with TS decorators).

```typescript
function Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log(`Calling ${propertyKey} with args: ${JSON.stringify(args)}`);
    const result = originalMethod.apply(this, args);
    console.log(`Result: ${result}`);
    return result;
  };

  return descriptor;
}

class UserService {
  @Log
  getUser(id: number) {
    return { id, name: 'John Doe' };
  }
}
```

#### Functional Alternative: Higher-Order Functions

```typescript
const withLogging = (fn: Function) => (...args: any[]) => {
  console.log(`Calling with ${args}`);
  return fn(...args);
};

const getUser = (id: number) => ({ id, name: 'John Doe' });
const getUserWithLog = withLogging(getUser);
```

### Facade

**The Concept:** Provides a simplified interface to a library, a framework, or any other complex set of classes.

**Real-world use case:** Wrapping a complex third-party SDK (like AWS S3 or Stripe) to expose only the methods your app needs.

```typescript
class VideoConverterFacade {
  convert(filename: string, format: string): void {
    const file = new VideoFile(filename);
    const sourceCodec = CodecFactory.extract(file);
    const destinationCodec = CodecFactory.get(format);
    const buffer = BitrateReader.read(filename, sourceCodec);
    const result = BitrateReader.convert(buffer, destinationCodec);
    new AudioMixer().fix(result);
    console.log('Conversion completed');
  }
}

// Usage
const converter = new VideoConverterFacade();
converter.convert('funny-cats-video.ogg', 'mp4');
```

### Proxy

**The Concept:** Lets you provide a substitute or placeholder for another object. A proxy controls access to the original object, allowing you to perform something either before or after the request gets through to the original object.

**Real-world use case:** Lazy loading heavy modules, caching API responses, or Vue.js reactivity system.

```typescript
interface API {
  getData(): string;
}

class RealAPI implements API {
  getData() {
    console.log('Fetching data from network...');
    return 'Data';
  }
}

class CachedAPIProxy implements API {
  private cache: string | null = null;

  constructor(private service: RealAPI) {}

  getData() {
    if (!this.cache) {
      this.cache = this.service.getData();
    }
    return this.cache;
  }
}
```

### Bridge

**The Concept:** Lets you split a large class or a set of closely related classes into two separate hierarchies—abstraction and implementation—which can be developed independently of each other.

**Real-world use case:** separating a UI (View) from the underlying data source (API vs LocalStorage), or a remote control (Abstraction) working with different devices (Implementation).

```typescript
interface Device {
  isEnabled(): boolean;
  enable(): void;
  disable(): void;
}

class RemoteControl {
  constructor(protected device: Device) {}

  togglePower() {
    if (this.device.isEnabled()) {
      this.device.disable();
    } else {
      this.device.enable();
    }
  }
}
```

### Composite

**The Concept:** Lets you compose objects into tree structures and then work with these structures as if they were individual objects.

**Real-world use case:** File systems (Folders contain Files and other Folders) or UI component trees (A Panel contains Buttons and other Panels).

```typescript
interface Component {
  render(): void;
}

class Button implements Component {
  render() { console.log('Rendering Button'); }
}

class Panel implements Component {
  private children: Component[] = [];

  add(component: Component) {
    this.children.push(component);
  }

  render() {
    console.log('Rendering Panel');
    this.children.forEach(c => c.render());
  }
}
```

### Flyweight

**The Concept:** Lets you fit more objects into the available amount of RAM by sharing common parts of state between multiple objects instead of keeping all of the data in each object.

**Real-world use case:** Rendering thousands of particles in a game or text characters in a word processor where shared data (texture, font) is stored once.

```typescript
class TreeType {
  constructor(private name: string, private color: string, private texture: string) {}
  draw(x: number, y: number) {
    console.log(`Drawing ${this.name} at (${x}, ${y})`);
  }
}

class TreeFactory {
  static types: Map<string, TreeType> = new Map();
  static getTreeType(name: string, color: string, texture: string) {
    const key = `${name}-${color}-${texture}`;
    if (!this.types.has(key)) {
      this.types.set(key, new TreeType(name, color, texture));
    }
    return this.types.get(key)!;
  }
}
```

## Behavioral Patterns

These patterns are concerned with algorithms and the assignment of responsibilities between objects.

### Observer

**The Concept:** Lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they're observing.

**Real-world use case:** React state management (Redux/Zustand listeners) or Node.js EventEmitters.

```typescript
interface Observer {
  update(data: any): void;
}

class NewsLetter {
  private subscribers: Observer[] = [];

  subscribe(observer: Observer) {
    this.subscribers.push(observer);
  }

  notify(data: any) {
    this.subscribers.forEach(sub => sub.update(data));
  }
}
```

#### Functional Alternative: Callbacks / Event Emitters

```typescript
type Listener = (data: any) => void;
const createNewsletter = () => {
  const listeners: Listener[] = [];
  return {
    subscribe: (fn: Listener) => listeners.push(fn),
    notify: (data: any) => listeners.forEach(fn => fn(data))
  };
};
```

### Strategy

**The Concept:** Lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable.

**Real-world use case:** Handling different payment strategies (Credit Card, PayPal, Stripe) interchangeably.

```typescript
interface PaymentStrategy {
  pay(amount: number): void;
}

class CreditCardPayment implements PaymentStrategy {
  pay(amount: number) { console.log(`Paid ${amount} via Credit Card`); }
}

class PayPalPayment implements PaymentStrategy {
  pay(amount: number) { console.log(`Paid ${amount} via PayPal`); }
}

class Checkout {
  constructor(private strategy: PaymentStrategy) {}

  processOrder(amount: number) {
    this.strategy.pay(amount);
  }
}
```

#### Functional Alternative: Passing Functions

```typescript
type PaymentStrategy = (amount: number) => void;
const payWithCard: PaymentStrategy = (amount) => console.log(`Card: ${amount}`);
const payWithPayPal: PaymentStrategy = (amount) => console.log(`PayPal: ${amount}`);

const processOrder = (amount: number, strategy: PaymentStrategy) => strategy(amount);
```

### Chain of Responsibility

**The Concept:** Lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.

**Real-world use case:** Express.js or NestJS middleware (Authentication -> Validation -> Logging -> Controller).

```typescript
abstract class Middleware {
  private next: Middleware | null = null;

  public setNext(middleware: Middleware): Middleware {
    this.next = middleware;
    return middleware;
  }

  public handle(request: string): void {
    if (this.next) {
      this.next.handle(request);
    }
  }
}

class AuthMiddleware extends Middleware {
  public handle(request: string): void {
    if (request === 'authenticated') {
      console.log('Auth passed');
      super.handle(request);
    } else {
      console.log('Auth failed');
    }
  }
}
```

### Command

**The Concept:** Turns a request into a stand-alone object that contains all information about the request. This transformation lets you pass requests as a method arguments, delay or queue a request's execution, and support undoable operations.

**Real-world use case:** Redux actions, implementing "Undo/Redo" functionality in editors, or job queues.

```typescript
interface Command {
  execute(): void;
}

class SaveCommand implements Command {
  constructor(private service: DataService) {}
  execute() {
    this.service.save();
  }
}

class Button {
  constructor(private command: Command) {}
  click() {
    this.command.execute();
  }
}
```

#### Functional Alternative: Closures / Thunks

```typescript
const createSaveCommand = (service: DataService) => () => service.save();
const buttonClick = (command: () => void) => command();
```

### State

**The Concept:** Lets an object alter its behavior when its internal state changes. It appears as if the object changed its class.

**Real-world use case:** Managing the state of a document (Draft -> InReview -> Published) or a connection (Connected, Disconnected, Reconnecting).

```typescript
interface State {
  publish(): void;
}

class DraftState implements State {
  publish() {
    console.log('Document sent to review.');
    // Transition to ReviewState...
  }
}

class PublishedState implements State {
  publish() {
    console.log('Document is already published.');
  }
}
```

#### Functional Alternative: Reducers (Redux style)

```typescript
type State = 'draft' | 'published';
type Action = { type: 'PUBLISH' };

const reducer = (state: State, action: Action): State => {
  if (state === 'draft' && action.type === 'PUBLISH') return 'published';
  return state;
};
```

### Iterator

**The Concept:** Lets you traverse elements of a collection without exposing its underlying representation (list, stack, tree, etc.).

**Real-world use case:** Iterating over complex data structures like Graphs or Trees, or simply making a custom collection compatible with `for...of` loops.

```typescript
class UserCollection implements Iterable<string> {
  private users: string[] = [];

  addUser(user: string) { this.users.push(user); }

  [Symbol.iterator](): Iterator<string> {
    let index = 0;
    return {
      next: (): IteratorResult<string> => {
        if (index < this.users.length) {
          return { value: this.users[index++], done: false };
        } else {
          return { value: null, done: true };
        }
      }
    };
  }
}
```

### Mediator

**The Concept:** Lets you reduce chaotic dependencies between objects. The pattern restricts direct communications between the objects and forces them to collaborate only via a mediator object.

**Real-world use case:** Chat room participants communicating via a central server, or UI components (Dialogs) communicating via a central Form Controller.

```typescript
interface Mediator {
  notify(sender: object, event: string): void;
}

class ConcreteMediator implements Mediator {
  constructor(private component1: Component1, private component2: Component2) {
    this.component1.setMediator(this);
    this.component2.setMediator(this);
  }

  notify(sender: object, event: string): void {
    if (event === 'A') {
      console.log('Mediator triggers B');
      this.component2.doC();
    }
  }
}
```

### Memento

**The Concept:** Lets you save and restore the previous state of an object without revealing the details of its implementation.

**Real-world use case:** Implementing "Undo" functionality in text editors or saving snapshots of game state.

```typescript
class Editor {
  constructor(private content: string) {}

  type(words: string) { this.content += words; }
  getContent() { return this.content; }

  save(): Snapshot { return new Snapshot(this.content); }
  restore(snapshot: Snapshot) { this.content = snapshot.getContent(); }
}

class Snapshot {
  constructor(private content: string) {}
  getContent() { return this.content; }
}
```

### Template Method

**The Concept:** Defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.

**Real-world use case:** Data parsers (CSVParser, JSONParser) that share the same "open file -> parse -> close file" flow but implement "parse" differently.

```typescript
abstract class DataMiner {
  mine(path: string) {
    const file = this.openFile(path);
    const rawData = this.extractData(file);
    const data = this.parseData(rawData);
    this.closeFile(file);
    return data;
  }

  abstract parseData(data: any): any;
  // ... other methods
  openFile(path: string) { return "file"; }
  extractData(file: any) { return "raw"; }
  closeFile(file: any) {}
}

class PDFMiner extends DataMiner {
  parseData(data: any) { return "PDF Data"; }
}
```

#### Functional Alternative: Higher-Order Functions

```typescript
const mineData = (path: string, parseFn: (data: any) => any) => {
  const file = openFile(path);
  const raw = extract(file);
  const data = parseFn(raw);
  close(file);
  return data;
};
```

### Visitor

**The Concept:** Lets you separate algorithms from the objects on which they operate.

**Real-world use case:** Exporting a graph of objects to XML/JSON, or performing operations (like auditing) on a heterogeneous set of nodes in a document object model (DOM).

```typescript
interface Shape {
  accept(visitor: Visitor): void;
}

class Circle implements Shape {
  accept(visitor: Visitor) { visitor.visitCircle(this); }
}

class Square implements Shape {
  accept(visitor: Visitor) { visitor.visitSquare(this); }
}

interface Visitor {
  visitCircle(c: Circle): void;
  visitSquare(s: Square): void;
}

class XMLExportVisitor implements Visitor {
  visitCircle(c: Circle) { console.log('Exporting Circle to XML'); }
  visitSquare(s: Square) { console.log('Exporting Square to XML'); }
}
```

#### Functional Alternative: Pattern Matching (Discriminated Unions)

```typescript
type Shape = 
  | { kind: 'circle', radius: number }
  | { kind: 'square', side: number };

const exportToXML = (shape: Shape) => {
  switch (shape.kind) {
    case 'circle': return `Circle(r=${shape.radius})`;
    case 'square': return `Square(s=${shape.side})`;
  }
};
```

### Null Object

**The Concept:** Provide an object as a surrogate for the lack of an object of a given type. The Null Object provides intelligent "do nothing" behavior.

**Real-world use case:** Avoiding `if (user !== null)` checks everywhere.

```typescript
interface User {
  getName(): string;
  hasAccess(): boolean;
}

class RealUser implements User {
  constructor(private name: string) {}
  getName() { return this.name; }
  hasAccess() { return true; }
}

class NullUser implements User {
  getName() { return 'Guest'; }
  hasAccess() { return false; }
}

// Usage
function getUser(id: number): User {
  return id === 1 ? new RealUser('Alice') : new NullUser();
}
```

#### Functional Alternative: Optional Chaining / Maybe

```typescript
const user = getUser(2); // returns null or undefined
const name = user?.name ?? 'Guest';
```

## Resources

- [Refactoring Guru - TypeScript Design Patterns](https://refactoring.guru/design-patterns/typescript)
- [Patterns.dev](https://www.patterns.dev/)
- [Head First Design Patterns](https://www.oreilly.com/library/view/head-first-design/0596007124/)

<Disclaimer />
