---
date: 2025-11-20
title: Advanced Data Structures
excerpt: "Moving beyond arrays and objects: exploring Linked Lists and Trees to solve complex architectural problems efficiently."
tags: [ 'TypeScript', 'Data Structures', 'Linked Lists', 'Trees', 'Binary Search Tree', 'Graphs', 'Tries' ]
lastUpdated: 2025-11-20
---
import Disclaimer from '~/components/Disclaimer.astro';

## The concept

While [Arrays and Objects](../14-data-structures) handle 90% of needs,
understanding advanced structures unlocks the ability to solve more complex
problems.

{/* <!-- truncate --> */}

### Stacks & Queues

While not native classes in JS (usually implemented with Arrays), the *pattern*
is extremely useful. 

- **Stack (LIFO)**: Last In, First Out. Think "Undo" functionality.
- **Queue (FIFO)**: First In, First Out. Think "Toast notifications" or
  background job processing. 

#### Usage with Arrays

```typescript
// Stack: Undo history
const history: string[] = [];
history.push('Type A');
history.push('Type B');
const lastAction = history.pop(); // 'Type B'

// Queue: Task processing
const taskQueue: string[] = [];
taskQueue.push('Email User');
taskQueue.push('Generate Report');
const nextTask = taskQueue.shift(); // 'Email User'
```

#### Simple Class Implementation

```typescript
class Stack<T> {
  private items: T[] = [];

  push(item: T): void {
    this.items.push(item);
  }

  pop(): T | undefined {
    return this.items.pop();
  }
}

class Queue<T> {
  private items: T[] = [];

  enqueue(item: T): void {
    this.items.push(item);
  }

  dequeue(): T | undefined {
    return this.items.shift();
  }
}
```

## Linked Lists

A linear collection of data elements where each element points to the next.

### Singly Linked List

Each node contains data and a reference (pointer) to the next node.

**Use Case**: An implementation of a Stack or Queue where you need constant-time
O(1) insertion and deletion at the beginning, without shifting all elements
like an Array would. 

```typescript
class ListNode<T> {
  value: T;
  next: ListNode<T> | null = null;

  constructor(value: T) {
    this.value = value;
  }
}

class LinkedList<T> {
  head: ListNode<T> | null = null;

  // O(1) insertion at the start
  prepend(value: T): void {
    const newNode = new ListNode(value);
    newNode.next = this.head;
    this.head = newNode;
  }
}

const list = new LinkedList<string>();
list.prepend('Third');
list.prepend('Second');
list.prepend('First');
// Structure: First -> Second -> Third -> null
```

### Doubly Linked List

Each node has pointers to both the **next** and **previous** nodes.

**Use Case**: Browser history (Back/Forward buttons), or a music playlist
player. 

```typescript
class DoublyNode<T> {
  value: T;
  next: DoublyNode<T> | null = null;
  prev: DoublyNode<T> | null = null;

  constructor(value: T) {
    this.value = value;
  }
}

class DoublyLinkedList<T> {
  head: DoublyNode<T> | null = null;
  tail: DoublyNode<T> | null = null;

  // O(1) insertion at the end
  append(value: T): void {
    const newNode = new DoublyNode(value);
    if (!this.tail) {
      this.head = this.tail = newNode;
    } else {
      newNode.prev = this.tail;
      this.tail.next = newNode;
      this.tail = newNode;
    }
  }

  // O(1) insertion at the start
  prepend(value: T): void {
    const newNode = new DoublyNode(value);
    if (!this.head) {
      this.head = this.tail = newNode;
    } else {
      newNode.next = this.head;
      this.head.prev = newNode;
      this.head = newNode;
    }
  }

  // O(1) deletion from the end
  removeLast(): T | null {
    if (!this.tail) return null;
    const value = this.tail.value;
    if (this.head === this.tail) {
      this.head = this.tail = null;
    } else {
      this.tail = this.tail.prev;
      this.tail!.next = null;
    }
    return value;
  }

  // O(1) deletion from the start
  removeFirst(): T | null {
    if (!this.head) return null;
    const value = this.head.value;
    if (this.head === this.tail) {
      this.head = this.tail = null;
    } else {
      this.head = this.head.next;
      this.head!.prev = null;
    }
    return value;
  }
}

// Imagine a music player playlist
const playlist = new DoublyLinkedList<string>();
playlist.append('Bohemian Rhapsody');
playlist.append('Stairway to Heaven');
playlist.append('Hotel California');

function playNext(current: DoublyNode<string>) {
  return current.next ? current.next : current; // Stop at end
}

function playPrevious(current: DoublyNode<string>) {
  return current.prev ? current.prev : current; // Stop at start
}
```

## Trees

A hierarchical structure consisting of nodes, with a single root node and
children nodes. 

**Use Case**: The **DOM** (Document Object Model), file systems, routers are trees.

```typescript
class TreeNode<T> {
  value: T;
  children: TreeNode<T>[] = [];

  constructor(value: T) {
    this.value = value;
  }

  addChild(node: TreeNode<T>): void {
    this.children.push(node);
  }
}

// Modeling a simple HTML structure
const html = new TreeNode('html');
const body = new TreeNode('body');
const div = new TreeNode('div');
const p = new TreeNode('p');

html.addChild(body);
body.addChild(div);
div.addChild(p);
```

### Binary Search Trees (BST)

A specific type of tree where each node has *at most* two children (left and
right). ⚠️: For any node, the left child is *smaller* and the right child
is *larger*. 

**Use Case**: Efficient searching and sorting (O(log n)).

```typescript
class BinaryNode<T> {
  value: T;
  left: BinaryNode<T> | null = null;
  right: BinaryNode<T> | null = null;

  constructor(value: T) {
    this.value = value;
  }
}

class BinarySearchTree<T> {
  root: BinaryNode<T> | null = null;

  insert(value: T): void {
    const newNode = new BinaryNode(value);
    if (!this.root) {
      this.root = newNode;
      return;
    }
    this.insertNode(this.root, newNode);
  }

  private insertNode(node: BinaryNode<T>, newNode: BinaryNode<T>): void {
    if (newNode.value < node.value) {
      // Go Left
      if (!node.left) node.left = newNode;
      else this.insertNode(node.left, newNode);
    } else {
      // Go Right
      if (!node.right) node.right = newNode;
      else this.insertNode(node.right, newNode);
    }
  }
}

const bst = new BinarySearchTree();
bst.insert(10);
bst.insert(5);
bst.insert(15);
//       10
//      /  \
//     5    15
```

## Graphs

A collection of nodes (vertices) and edges that connect pairs of nodes. Graphs
can be directed (Twitter followers) or undirected (Facebook friends). 

**Use Case**: Social networks, recommendation engines ("People who bought X also
bought Y"), and routing algorithms (Google Maps). 

```typescript
class Graph {
  // Adjacency List: Map<Node, Array<Neighbors>>
  adjacencyList: Map<string, string[]> = new Map();

  addVertex(vertex: string): void {
    if (this.adjacencyList.has(vertex)) return;

    this.adjacencyList.set(vertex, []);
  }

  addEdge(vertex1: string, vertex2: string): void {
    this.adjacencyList.get(vertex1)?.push(vertex2);
    this.adjacencyList.get(vertex2)?.push(vertex1); // Undirected
  }
}

const socialNetwork = new Graph();
socialNetwork.addVertex('Alice');
socialNetwork.addVertex('Bob');
socialNetwork.addVertex('Charlie');

socialNetwork.addEdge('Alice', 'Bob');
socialNetwork.addEdge('Alice', 'Charlie');
// Alice is friends with Bob and Charlie
```

## Tries (Prefix Trees)

A specialized tree used to store associative data structures. A node's position
in the tree defines the key with which it is associated. 

**Use Case**: Autocomplete / Typeahead systems. If you type "Re", a Trie can
efficiently find "React", "Redux", "Remix" without scanning a whole database. 

```typescript
class TrieNode {
  children: Map<string, TrieNode> = new Map();
  isEndOfWord: boolean = false;
}

class Trie {
  root: TrieNode = new TrieNode();

  insert(word: string): void {
    let current = this.root;
    for (const char of word) {
      if (!current.children.has(char)) {
        current.children.set(char, new TrieNode());
      }
      current = current.children.get(char)!;
    }
    current.isEndOfWord = true;
  }

  search(word: string): boolean {
    let current = this.root;
    for (const char of word) {
      if (!current.children.has(char)) return false;
      current = current.children.get(char)!;
    }
    return current.isEndOfWord;
  }
}

const autocomplete = new Trie();
autocomplete.insert('react');
autocomplete.insert('redux');
// Efficiently stores 'r', 'e', then branches for 'a' and 'd'
```

## Resources

- Visualizing Data Structures with [VisuAlgo](https://visualgo.net/en)
- Singly Linked List by [Nicholas C.
  Zakas](https://humanwhocodes.com/blog/2009/04/13/computer-science-in-javascript-linked-list/) 
- Doubly Linked List by [Nicholas C.
  Zakas](https://humanwhocodes.com/blog/2009/04/21/computer-science-in-javascript-doubly-linked-lists/) 
- Binary Search Tree by [Nicholas C.
  Zakas](https://humanwhocodes.com/blog/2009/06/09/computer-science-in-javascript-binary-search-tree-part-1/)
- Other data structures by Fireship.io on
  [YouTube](https://www.youtube.com/watch?v=6fnmXX8RK0s)

<Disclaimer />
